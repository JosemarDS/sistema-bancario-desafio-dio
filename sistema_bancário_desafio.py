# -*- coding: utf-8 -*-
"""Sistema Bancário - Desafio

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RRUqPCknxPM_oMn7bElSpo-HrslMJsEm
"""

# ============= SISTEMA BANCÁRIO V2 ============= #
# Autor: Josemar Joel Damião Sebastião
# Objetivo: Código modularizado com funções e suporte a múltiplos usuários e contas.

# Constantes globais
LIMITE_SAQUES = 3 # Define o limite de saques diários como 3
AGENCIA = "0001" # Define o número da agência como "0001"

# ---------------- FUNÇÕES PRINCIPAIS ---------------- #

def depositar(saldo, valor, extrato, /): # Define a função depositar com argumentos posicionais (saldo, valor, extrato)
    """
    Função de depósito.

    Args:
        saldo (float): Saldo atual da conta.
        valor (float): Valor a ser depositado.
        extrato (str): Histórico de transações.

    Returns:
        tuple: Saldo atualizado e extrato atualizado.
    """
    if valor > 0: # Verifica se o valor do depósito é positivo
        saldo += valor # Adiciona o valor ao saldo
        extrato += f"Depósito: R$ {valor:.2f}\n" # Adiciona a transação ao extrato
        print("\n✅ Depósito realizado com sucesso!") # Imprime mensagem de sucesso
    else: # Caso o valor não seja positivo
        print("\n❌ Operação falhou! O valor informado é inválido.") # Imprime mensagem de erro
    return saldo, extrato # Retorna o saldo e o extrato atualizados


def sacar(*, saldo, valor, extrato, limite, numero_saques, limite_saques): # Define a função sacar com argumentos nomeados
    """
    Função de saque.

    Args:
        saldo (float): Saldo atual da conta.
        valor (float): Valor a ser sacado.
        extrato (str): Histórico de transações.
        limite (float): Limite máximo por saque.
        numero_saques (int): Número de saques realizados no dia.
        limite_saques (int): Limite máximo de saques por dia.

    Returns:
        tuple: Saldo atualizado, extrato atualizado e número de saques atualizado.
    """
    excedeu_saldo = valor > saldo # Verifica se o valor do saque excede o saldo disponível
    excedeu_limite = valor > limite # Verifica se o valor do saque excede o limite por saque
    excedeu_saques = numero_saques >= limite_saques # Verifica se o número de saques excede o limite diário

    if excedeu_saldo: # Se excedeu o saldo
        print("\n❌ Operação falhou! Saldo insuficiente.") # Imprime mensagem de erro
    elif excedeu_limite: # Se excedeu o limite por saque
        print("\n❌ Operação falhou! Valor do saque excede o limite permitido.") # Imprime mensagem de erro
    elif excedeu_saques: # Se excedeu o limite diário de saques
        print("\n❌ Operação falhou! Número máximo de saques atingido.") # Imprime mensagem de erro
    elif valor > 0: # Se o valor do saque for positivo e não exceder os limites
        saldo -= valor # Subtrai o valor do saldo
        extrato += f"Saque: R$ {valor:.2f}\n" # Adiciona a transação ao extrato
        numero_saques += 1 # Incrementa o contador de saques
        print("\n✅ Saque realizado com sucesso!") # Imprime mensagem de sucesso
    else: # Caso o valor não seja positivo
        print("\n❌ Operação falhou! Valor inválido.") # Imprime mensagem de erro

    return saldo, extrato, numero_saques # Retorna o saldo, extrato e número de saques atualizados


def exibir_extrato(saldo, /, *, extrato): # Define a função exibir_extrato com argumento posicional (saldo) e nomeado (extrato)
    """
    Função para exibir o extrato.

    Args:
        saldo (float): Saldo atual da conta (posicional).
        extrato (str): Histórico de transações (nomeado).
    """
    print("\n================ EXTRATO ================") # Imprime o cabeçalho do extrato
    print("Não foram realizadas movimentações." if not extrato else extrato) # Imprime mensagem se o extrato estiver vazio ou o conteúdo do extrato
    print(f"\nSaldo atual: R$ {saldo:.2f}") # Imprime o saldo atual
    print("==========================================") # Imprime o rodapé do extrato


# ---------------- FUNÇÕES DE USUÁRIOS E CONTAS ---------------- #

def criar_usuario(usuarios): # Define a função criar_usuario
    """
    Cria um novo usuário.

    Args:
        usuarios (list): Lista de usuários existentes.
    """
    cpf = input("Informe o CPF (somente números): ") # Solicita o CPF do usuário
    usuario = filtrar_usuario(cpf, usuarios) # Filtra a lista de usuários para verificar se o CPF já existe

    if usuario: # Se o usuário com o CPF já existir
        print("\n⚠️ Já existe um usuário com este CPF!") # Imprime mensagem de aviso
        return # Sai da função

    nome = input("Informe o nome completo: ") # Solicita o nome completo do usuário
    data_nascimento = input("Informe a data de nascimento (dd-mm-aaaa): ") # Solicita a data de nascimento do usuário
    endereco = input("Informe o endereço (logradouro, nº - bairro - cidade/UF): ") # Solicita o endereço do usuário

    usuarios.append({ # Adiciona o novo usuário à lista de usuários
        "nome": nome,
        "data_nascimento": data_nascimento,
        "cpf": cpf,
        "endereco": endereco
    })
    print("\n✅ Usuário criado com sucesso!") # Imprime mensagem de sucesso


def filtrar_usuario(cpf, usuarios): # Define a função filtrar_usuario
    """
    Retorna o usuário com base no CPF.

    Args:
        cpf (str): CPF do usuário a ser filtrado.
        usuarios (list): Lista de usuários existentes.

    Returns:
        dict or None: O usuário encontrado ou None se não encontrado.
    """
    usuarios_filtrados = [usuario for usuario in usuarios if usuario["cpf"] == cpf] # Filtra a lista de usuários pelo CPF
    return usuarios_filtrados[0] if usuarios_filtrados else None # Retorna o primeiro usuário encontrado ou None


def criar_conta(agencia, numero_conta, usuarios): # Define a função criar_conta
    """
    Cria uma nova conta corrente para um usuário existente.

    Args:
        agencia (str): Número da agência.
        numero_conta (int): Próximo número de conta disponível.
        usuarios (list): Lista de usuários existentes.

    Returns:
        dict or None: A nova conta criada ou None se o usuário não for encontrado.
    """
    cpf = input("Informe o CPF do titular: ") # Solicita o CPF do titular da conta
    usuario = filtrar_usuario(cpf, usuarios) # Filtra a lista de usuários para encontrar o titular

    if usuario: # Se o usuário titular for encontrado
        print("\n✅ Conta criada com sucesso!") # Imprime mensagem de sucesso
        return { # Retorna os dados da nova conta
            "agencia": agencia,
            "numero_conta": numero_conta,
            "usuario": usuario
        }

    print("\n❌ Usuário não encontrado. Criação de conta encerrada.") # Imprime mensagem de erro se o usuário não for encontrado
    return None # Retorna None se o usuário não for encontrado


def listar_contas(contas): # Define a função listar_contas
    """
    Lista todas as contas cadastradas.

    Args:
        contas (list): Lista de contas existentes.
    """
    print("\n============= CONTAS CADASTRADAS =============") # Imprime o cabeçalho da lista de contas
    for conta in contas: # Itera sobre a lista de contas
        linha = f"""
Agência:\t{conta['agencia']}
C/C:\t\t{conta['numero_conta']}
Titular:\t{conta['usuario']['nome']}
""" # Formata as informações de cada conta
        print(linha) # Imprime as informações da conta
        print("=" * 40) # Imprime uma linha separadora


# ---------------- PROGRAMA PRINCIPAL ---------------- #

def main(): # Define a função principal do programa
    """Função principal do sistema bancário."""
    saldo = 0 # Inicializa o saldo da conta
    limite = 500 # Inicializa o limite de saque por operação
    extrato = "" # Inicializa o extrato como uma string vazia
    numero_saques = 0 # Inicializa o contador de saques diários
    usuarios = [] # Inicializa a lista de usuários
    contas = [] # Inicializa a lista de contas
    numero_conta = 1 # Inicializa o número da próxima conta a ser criada

    menu = """
================ MENU ================
[d] Depositar
[s] Sacar
[e] Extrato
[nu] Novo Usuário
[nc] Nova Conta
[lc] Listar Contas
[q] Sair
=> """ # Define o menu de opções do sistema

    while True: # Inicia um loop infinito para o menu
        opcao = input(menu).lower() # Solicita a opção do usuário e converte para minúscula

        if opcao == "d": # Se a opção for 'd' (Depositar)
            valor = float(input("Informe o valor do depósito: ")) # Solicita o valor do depósito
            saldo, extrato = depositar(saldo, valor, extrato) # Chama a função depositar

        elif opcao == "s": # Se a opção for 's' (Sacar)
            valor = float(input("Informe o valor do saque: ")) # Solicita o valor do saque
            saldo, extrato, numero_saques = sacar( # Chama a função sacar com argumentos nomeados
                saldo=saldo,
                valor=valor,
                extrato=extrato,
                limite=limite,
                numero_saques=numero_saques,
                limite_saques=LIMITE_SAQUES,
            )

        elif opcao == "e": # Se a opção for 'e' (Extrato)
            exibir_extrato(saldo, extrato=extrato) # Chama a função exibir_extrato

        elif opcao == "nu": # Se a opção for 'nu' (Novo Usuário)
            criar_usuario(usuarios) # Chama a função criar_usuario

        elif opcao == "nc": # Se a opção for 'nc' (Nova Conta)
            conta = criar_conta(AGENCIA, numero_conta, usuarios) # Chama a função criar_conta
            if conta: # Se a conta for criada com sucesso
                contas.append(conta) # Adiciona a nova conta à lista de contas
                numero_conta += 1 # Incrementa o número da próxima conta

        elif opcao == "lc": # Se a opção for 'lc' (Listar Contas)
            listar_contas(contas) # Chama a função listar_contas

        elif opcao == "q": # Se a opção for 'q' (Sair)
            print("\n👋 Encerrando o sistema bancário. Até logo!") # Imprime mensagem de despedida
            break # Sai do loop while

        else: # Se a opção for inválida
            print("\n❌ Opção inválida, tente novamente.") # Imprime mensagem de erro


# Execução do programa principal
if __name__ == "__main__": # Verifica se o script está sendo executado diretamente
    main() # Chama a função principal